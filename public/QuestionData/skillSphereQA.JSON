{

  "skillSphereQA": [

    {

      "topic": "HTML",

      "questions": [

        {

          "id": 1,

          "level": "Basic",

          "sub_topic": "Tags and Elements",

          "question_en": "What is an HTML tag?",

          "question_bn": "HTML ট্যাগ কী?",

          "details": {

            "what_is_en": "HTML tags are keywords enclosed in angle brackets (< >) that tell the browser how to display content.",

            "what_is_bn": "HTML ট্যাগ হলো অ্যাঙ্গেল ব্র্যাকেট (< >) দিয়ে ঘেরা কীওয়ার্ড, যা ব্রাউজারকে বলে দেয় কীভাবে কন্টেন্ট প্রদর্শন করতে হবে।"

          },

          "vip_qa": {

            "question_en": "What is the core difference between <b> and <strong> tags?",

            "answer_en": "The <b> tag only makes text bold visually, carrying no semantic meaning. The <strong> tag, however, makes the text bold and also signifies to browsers and screen readers that the content is important. For SEO and Accessibility, <strong> should be used."

          }

        },

        {

          "id": 2,

          "level": "Basic",

          "sub_topic": "Tags and Elements",

          "question_en": "What is an HTML element?",

          "question_bn": "HTML এলিমেন্ট কী?",

          "details": {

            "what_is_en": "An HTML element is the complete unit, including the opening tag, the content, and the closing tag.",

            "what_is_bn": "একটি HTML এলিমেন্ট হলো ওপেনিং ট্যাগ, কন্টেন্ট এবং ক্লোজিং ট্যাগ—সবকিছু মিলিয়ে একটি পূর্ণাঙ্গ অংশ।"

          },

          "vip_qa": {

            "question_en": "What distinguishes an empty element from a regular element?",

            "answer_en": "A regular element has an opening tag, content, and a closing tag (e.g., <p>...</p>). An empty element has no content or closing tag and is self-closing (e.g., <br>, <img>, <hr>)."

          }

        },

        {

          "id": 3,

          "level": "Basic",

          "sub_topic": "Attributes",

          "question_en": "What is an HTML attribute?",

          "question_bn": "HTML অ্যাট্রিবিউট কী?",

          "details": {

            "what_is_en": "Attributes provide additional information about HTML elements and are always included in the opening tag.",

            "what_is_bn": "অ্যাট্রিবিউট হলো HTML এলিমেন্টের অতিরিক্ত তথ্য, যা ওপেনিং ট্যাগের ভেতরে লেখা হয়।"

          },

          "vip_qa": {

            "question_en": "What is the purpose of the `data-*` attribute?",

            "answer_en": "The `data-*` attributes are used to store custom data private to the page or application, which can be easily accessed by JavaScript for creating more dynamic user experiences without misusing standard attributes."

          }

        },

        {

          "id": 4,

          "level": "Basic",

          "sub_topic": "Attributes",

          "question_en": "What is the difference between `id` and `class` attributes?",

          "question_bn": "id এবং class অ্যাট্রিবিউটের মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "`id` is used to uniquely identify a single element on a page, while `class` is used to group multiple elements.",

            "what_is_bn": "`id` একটি পেজে একটি নির্দিষ্ট এলিমেন্টকে ইউনিকভাবে শনাক্ত করতে ব্যবহৃত হয়, আর `class` একাধিক এলিমেন্টকে একই গ্রুপে ভাগ করতে ব্যবহৃত হয়।"

          },

          "vip_qa": {

            "question_en": "In what scenario is it more logical to use a `class` instead of an `id`?",

            "answer_en": "You should always use a `class` when you anticipate applying the same style or behavior to multiple elements. Since an `id` must be unique per page, it's not reusable. Using classes is a best practice for creating reusable components and maintaining a scalable CSS architecture."

          }

        },

        {

          "id": 5,

          "level": "Intermediate",

          "sub_topic": "Semantic Tags",

          "question_en": "What are semantic tags?",

          "question_bn": "সেম্যান্টিক ট্যাগ কী?",

          "details": {

            "what_is_en": "Semantic tags are HTML tags that clearly describe their meaning to both the browser and the developer, such as <header>, <article>, and <footer>.",

            "what_is_bn": "সেম্যান্টিক ট্যাগগুলো এমন ট্যাগ যা ব্রাউজার এবং ডেভেলপার উভয়কেই নিজের কন্টেন্টের অর্থ স্পষ্টভাবে বুঝিয়ে দেয়।"

          },

          "vip_qa": {

            "question_en": "What is the difference between `<section>` and `<article>`?",

            "answer_en": "An `<article>` is for self-contained, independent content that could be distributed on its own (e.g., a blog post). A `<section>` is used to group related content within a document (e.g., an introduction section). An `<article>` can contain `<section>`s, and a `<section>` can contain `<article>`s."

          }

        },

        {

          "id": 6,

          "level": "Intermediate",

          "sub_topic": "Forms and Inputs",

          "question_en": "How do HTML forms work?",

          "question_bn": "HTML ফর্ম কীভাবে কাজ করে?",

          "details": {

            "what_is_en": "HTML forms, using the <form> element, are used to collect user input and send it to a server for processing.",

            "what_is_bn": "HTML ফর্ম `<form>` এলিমেন্ট ব্যবহার করে ইউজারের কাছ থেকে ডেটা সংগ্রহ করে সার্ভারে পাঠানোর জন্য ব্যবহৃত হয়।"

          },

          "vip_qa": {

            "question_en": "What is the difference between GET and POST form methods?",

            "answer_en": "**GET** appends form data to the URL, is visible in browser history, and has size limitations. It's suitable for search queries. **POST** sends form data in the HTTP request body, is more secure as it's not visible in the URL, and has no size limitations. It's used for creating or updating data."

          }

        },

        {

          "id": 7,

          "level": "Advanced",

          "sub_topic": "Media and Embedding",

          "question_en": "What is the difference between `<img>`, `<picture>`, and CSS `background-image`?",

          "question_bn": "`<img>`, `<picture>`, এবং `background-image` এর মধ্যে কোনটি কখন ব্যবহার করবেন?",

          "details": {

            "what_is_en": "`<img>` is for content-critical images. `<picture>` is for responsive art direction, serving different images based on viewport. `background-image` is for decorative images that are part of the design, not the content.",

            "what_is_bn": "`<img>` কন্টেন্টের অংশ হিসেবে ছবি দেখানোর জন্য। `<picture>` রেসপন্সিভ ডিজাইনের জন্য। `background-image` ডিজাইন বা ডেকোরেশনের জন্য।"

          },

          "vip_qa": {

            "question_en": "What are two major security risks of using `<iframe>` and how can they be mitigated?",

            "answer_en": "1. **Clickjacking:** An attacker can overlay a transparent `<iframe>` to trick users into clicking malicious links. This is mitigated by the server sending the `X-Frame-Options` HTTP header. 2. **Cross-Site Scripting (XSS):** Malicious content inside an iframe can potentially harm the parent site. This is mitigated by using the `sandbox` attribute on the `<iframe>` tag to restrict its capabilities."

          }

        },

        {

          "id": 8,

          "level": "Advanced",

          "sub_topic": "Accessibility",

          "question_en": "What is ARIA in HTML?",

          "question_bn": "HTML-এ ARIA কী?",

          "details": {

            "what_is_en": "ARIA (Accessible Rich Internet Applications) is a set of attributes you can add to HTML elements to improve their accessibility for people who use assistive technologies like screen readers.",

            "what_is_bn": "ARIA হলো এমন কিছু অ্যাট্রিবিউট যা HTML এলিমেন্টে যোগ করে অ্যাসিস্টিভ টেকনোলজি ব্যবহারকারীদের জন্য অ্যাক্সেসিবিলিটি উন্নত করা হয়।"

          },

          "vip_qa": {

            "question_en": "When should you use ARIA roles versus using semantic HTML elements?",

            "answer_en": "The first rule of ARIA is: 'Don't use ARIA if you can use a native HTML element'. You should always prefer using a semantic HTML element like `<button>` or `<nav>` over adding an ARIA role to a generic `<div>`. Use ARIA only to bridge gaps where standard HTML semantics are insufficient."

          }

        },

        {

          "id": 9,

          "level": "Basic",

          "sub_topic": "Structure",

          "question_en": "What is the purpose of the `<!DOCTYPE html>` declaration?",

          "question_bn": "`<!DOCTYPE html>` ঘোষণার উদ্দেশ্য কী?",

          "details": {

            "what_is_en": "The `<!DOCTYPE html>` declaration is an instruction to the web browser about what version of HTML the page is written in. For HTML5, this simple declaration is all that's needed to ensure the page renders in 'standards mode'.",

            "what_is_bn": "`<!DOCTYPE html>` ঘোষণাটি ওয়েব ব্রাউজারকে বলে দেয় যে পেজটি কোন HTML ভার্সনে লেখা হয়েছে।"

          },

          "vip_qa": {

            "question_en": "What happens if you omit the `<!DOCTYPE html>` declaration?",

            "answer_en": "If the doctype is omitted, browsers will enter 'Quirks Mode'. In this mode, the browser attempts to emulate the behavior of older browsers. This can lead to unpredictable and inconsistent rendering of CSS and layout across different browsers."

          }

        },

        {

          "id": 10,

          "level": "Intermediate",

          "sub_topic": "Tables",

          "question_en": "What are the essential tags for creating a basic HTML table?",

          "question_bn": "একটি বেসিক HTML টেবিল তৈরির জন্য প্রয়োজনীয় ট্যাগগুলো কী কী?",

          "details": {

            "what_is_en": "The essential tags are `<table>` to define the table, `<tr>` for table rows, `<th>` for table headers, and `<td>` for table data cells.",

            "what_is_bn": "প্রয়োজনীয় ট্যাগগুলো হলো `<table>`, `<tr>`, `<th>`, এবং `<td>`।"

          },

          "vip_qa": {

            "question_en": "For accessibility, what is the purpose of `<thead>`, `<tbody>`, and `<tfoot>` elements?",

            "answer_en": "These elements provide semantic structure. `<thead>` groups the header, `<tbody>` groups the body, and `<tfoot>` groups the footer. This is important for: 1. **Accessibility:** Screen readers can use these to provide better context. 2. **Styling:** It provides hooks for specific CSS. 3. **Functionality:** It allows the browser to scroll the table body independently of the header and footer."

          }

        },

        {

          "id": 11,

          "level": "Advanced",

          "sub_topic": "HTML5 APIs",

          "question_en": "What is the difference between LocalStorage and SessionStorage?",

          "question_bn": "LocalStorage এবং SessionStorage-এর মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "Both are web storage APIs. **LocalStorage** data persists even after the browser is closed. **SessionStorage** data is cleared when the page session ends (when the tab is closed).",

            "what_is_bn": "দুটোই ওয়েব স্টোরেজ API। **LocalStorage**-এর ডেটা ব্রাউজার বন্ধ করার পরেও থেকে যায়। **SessionStorage**-এর ডেটা ট্যাব বন্ধ হলে মুছে যায়।"

          },

          "vip_qa": {

            "question_en": "What are the security implications of storing a JWT in LocalStorage? What is a safer alternative?",

            "answer_en": "Storing a JWT in LocalStorage is vulnerable to **Cross-Site Scripting (XSS)** attacks. If an attacker injects malicious JavaScript, they can read the token. A safer alternative is to store the JWT in an **`HttpOnly` cookie**. An `HttpOnly` cookie cannot be accessed by client-side JavaScript, mitigating this risk."

          }

        },

        {

          "id": 12,

          "level": "Basic",

          "sub_topic": "Links",

          "question_en": "How do you create a hyperlink that opens in a new tab?",

          "question_bn": "নতুন ট্যাবে খোলে এমন হাইপারলিঙ্ক কীভাবে তৈরি করবেন?",

          "details": {

            "what_is_en": "You use the `<a>` tag with the `href` attribute for the URL and the `target=\"_blank\"` attribute to open it in a new tab.",

            "what_is_bn": "`<a>` ট্যাগের সাথে `href` অ্যাট্রিবিউট এবং `target=\"_blank\"` অ্যাট্রিবিউট ব্যবহার করে।"

          },

          "vip_qa": {

            "question_en": "What security vulnerability is associated with `target=\"_blank\"` and how do you fix it?",

            "answer_en": "The vulnerability is called **tabnabbing**. The new page gets access to the original page via `window.opener`, which it can use to redirect the original page to a malicious site. To fix this, you must add `rel=\"noopener noreferrer\"` to your `<a>` tags that use `target=\"_blank\"`."

          }

        },

        {

          "id": 13,

          "level": "Intermediate",

          "sub_topic": "Forms",

          "question_en": "What is the purpose of the `<label>` tag?",

          "question_bn": "ফর্মে `<label>` ট্যাগের উদ্দেশ্য কী?",

          "details": {

            "what_is_en": "The `<label>` tag defines a label for form elements, improving usability and accessibility. Clicking on the label focuses the associated input.",

            "what_is_bn": "`<label>` ট্যাগ ফর্ম এলিমেন্টের জন্য একটি লেবেল ডিফাইন করে, যা ব্যবহারযোগ্যতা এবং অ্যাক্সেসিবিলিটি উন্নত করে।"

          },

          "vip_qa": {

            "question_en": "What are the two ways to associate a `<label>` with an `<input>`, and which is better?",

            "answer_en": "1. **Wrapping:** You can wrap the `<input>` inside the `<label>`. 2. **Using `for`/`id`:** Use the `for` attribute on the `<label>`, which should match the `id` of the `<input>`. The **`for`/`id` method is generally better** as it's more robust for assistive technologies and allows for flexible layouts."

          }

        },

        {

          "id": 14,

          "level": "Advanced",

          "sub_topic": "The DOM",

          "question_en": "What is the HTML DOM?",

          "question_bn": "HTML DOM কী?",

          "details": {

            "what_is_en": "The DOM (Document Object Model) is a programming interface that represents a web page as a tree of nodes and objects. It allows programs like JavaScript to access and manipulate the page's content, structure, and style.",

            "what_is_bn": "DOM হলো ওয়েব ডকুমেন্টের জন্য একটি প্রোগ্রামিং ইন্টারফেস, যা একটি পেজকে নোড এবং অবজেক্টের একটি ট্রি হিসেবে উপস্থাপন করে।"

          },

          "vip_qa": {

            "question_en": "What is the difference between the DOM and the Shadow DOM?",

            "answer_en": "The **DOM** is the standard model for the entire document. The **Shadow DOM** is a web standard that allows for encapsulated DOM trees with their own styles and scripts. These encapsulated trees (shadow roots) are attached to an element but are isolated from the main document DOM. This is the technology that powers Web Components."

          }

        },

        {

          "id": 15,

          "level": "Intermediate",

          "sub_topic": "Attributes",

          "question_en": "What does the `alt` attribute on an `<img>` tag do?",

          "question_bn": "`<img>` ট্যাগে `alt` অ্যাট্রিবিউটের কাজ কী?",

          "details": {

            "what_is_en": "The `alt` (alternative text) attribute provides a textual description of an image. It is crucial for accessibility, as screen readers read it aloud to visually impaired users, and it's also displayed if the image fails to load.",

            "what_is_bn": "`alt` অ্যাট্রিবিউট একটি ছবির পাঠ্য বিবরণ প্রদান করে। এটি অ্যাক্সেসিবিলিটির জন্য অপরিহার্য।"

          },

          "vip_qa": {

            "question_en": "When is it appropriate to use an empty `alt=\"\"` attribute?",

            "answer_en": "An empty `alt` attribute (`alt=\"\"`) should be used for images that are purely **decorative**. If an image does not convey any meaningful content and is just for visual styling (e.g., a spacer image), an empty alt text tells screen readers to ignore it. Omitting the `alt` attribute entirely is bad practice."

          }

        },

        {

          "id": 16,

          "level": "Basic",

          "sub_topic": "Lists",

          "question_en": "What are the three types of lists in HTML?",

          "question_bn": "HTML এ তিন ধরনের লিস্ট কী কী?",

          "details": {

              "what_is_en": "The three types are: 1. `<ol>` for ordered lists (numbered), 2. `<ul>` for unordered lists (bulleted), and 3. `<dl>` for description lists (term-description pairs). All use `<li>` for list items, except `<dl>` which uses `<dt>` and `<dd>`.",

              "what_is_bn": "তিন প্রকার লিস্ট হলো: ১. `<ol>` অর্ডার করা লিস্ট (সংখ্যাযুক্ত), ২. `<ul>` আনঅর্ডার করা লিস্ট (বুলেটযুক্ত), এবং ৩. `<dl>` বর্ণনা লিস্ট।"

          },

          "vip_qa": {

              "question_en": "Can you nest lists within each other? How?",

              "answer_en": "Yes, you can nest lists. To do so, you place a new `<ul>` or `<ol>` element inside an `<li>` element of the parent list. This is the correct semantic structure for creating sub-lists."

          }

        }

      ]

    },

    {

      "topic": "CSS",

      "questions": [

        {

          "id": 17,

          "level": "Basic",

          "sub_topic": "Selectors and Basic Styling",

          "question_en": "What is CSS?",

          "question_bn": "CSS কী?",

          "details": {

            "what_is_en": "CSS (Cascading Style Sheets) is a style sheet language used for describing the presentation of a document written in a markup language like HTML.",

            "what_is_bn": "CSS হলো একটি স্টাইল শিট ভাষা যা HTML ডকুমেন্টের presentation বর্ণনা করতে ব্যবহৃত হয়।"

          },

          "vip_qa": {

            "question_en": "What does the term 'Cascading' mean in CSS?",

            "answer_en": "'Cascading' refers to the algorithm that determines how styles are applied to an element when multiple rules could apply. It's a priority scheme based on three factors: 1) Specificity, 2) Importance (`!important`), and 3) Source Order."

          }

        },

        {

          "id": 18,

          "level": "Basic",

          "sub_topic": "The Box Model",

          "question_en": "What is the CSS Box Model?",

          "question_bn": "CSS বক্স মডেল কী?",

          "details": {

            "what_is_en": "In CSS, every HTML element is treated as a rectangular box. The box model consists of four parts: Content, Padding, Border, and Margin.",

            "what_is_bn": "CSS-এ প্রতিটি HTML এলিমেন্ট একটি আয়তক্ষেত্রাকার বক্স হিসেবে বিবেচিত হয়, যা Content, Padding, Border, এবং Margin নিয়ে গঠিত।"

          },

          "vip_qa": {

            "question_en": "What does `box-sizing: border-box;` do, and why is it a best practice?",

            "answer_en": "By default, an element's `width` and `height` properties only apply to its content. `box-sizing: border-box;` changes this so that `width` and `height` include the content, padding, and border. This makes creating layouts much more intuitive and predictable."

          }

        },

        {

          "id": 19,

          "level": "Intermediate",

          "sub_topic": "Positioning and Layout",

          "question_en": "What is Flexbox?",

          "question_bn": "Flexbox কী?",

          "details": {

            "what_is_en": "Flexbox is a one-dimensional layout model that helps arrange, align, and distribute space among items in a container.",

            "what_is_bn": "Flexbox একটি এক-মাত্রিক লেআউট মডেল যা আইটেমগুলোকে একটি কন্টেইনারের মধ্যে সাজাতে সাহায্য করে।"

          },

          "vip_qa": {

            "question_en": "What's the difference between `justify-content` and `align-items`?",

            "answer_en": "`justify-content` aligns items along the main axis (typically horizontal). `align-items` aligns items along the cross axis (typically vertical). They control alignment in different dimensions."

          }

        },

        {

          "id": 20,

          "level": "Intermediate",

          "sub_topic": "Positioning and Layout",

          "question_en": "What is CSS Grid?",

          "question_bn": "CSS Grid কী?",

          "details": {

            "what_is_en": "CSS Grid is a two-dimensional layout system that allows you to arrange content in rows and columns.",

            "what_is_bn": "CSS Grid একটি দ্বি-মাত্রিক লেআউট সিস্টেম যা কন্টেন্টকে সারি এবং কলামে সাজাতে ব্যবহৃত হয়।"

          },

          "vip_qa": {

            "question_en": "When should you use Flexbox versus CSS Grid?",

            "answer_en": "Use **Flexbox** for one-dimensional layouts (aligning items in a row OR a column). Use **CSS Grid** for two-dimensional layouts (aligning items in rows AND columns simultaneously). They are often used together."

          }

        },

        {

          "id": 21,

          "level": "Advanced",

          "sub_topic": "Responsive Design & Advanced Features",

          "question_en": "What is CSS Specificity?",

          "question_bn": "CSS Specificity কী?",

          "details": {

            "what_is_en": "Specificity is the algorithm used by browsers to determine which CSS rule is applied to an element when multiple conflicting rules exist.",

            "what_is_bn": "Specificity হলো একটি নিয়ম যা ব্রাউজারকে নির্ধারণ করতে সাহায্য করে যে কোন CSS রুলটি প্রয়োগ হবে।"

          },

          "vip_qa": {

            "question_en": "What is `!important` and why should its use be avoided?",

            "answer_en": "`!important` is a rule that overrides all other specificity rules. It should be avoided because it breaks the natural cascading flow of CSS, making the code extremely difficult to debug and maintain."

          }

        },

        {

          "id": 22,

          "level": "Intermediate",

          "sub_topic": "Selectors",

          "question_en": "What is the difference between a pseudo-class and a pseudo-element?",

          "question_bn": "Pseudo-class এবং pseudo-element এর মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "A **pseudo-class** defines a special state of an element (e.g., `:hover`). A **pseudo-element** styles a specific part of an element (e.g., `::before`).",

            "what_is_bn": "**Pseudo-class** একটি এলিমেন্টের বিশেষ অবস্থাকে সিলেক্ট করে। **Pseudo-element** একটি এলিমেন্টের নির্দিষ্ট অংশকে স্টাইল করে।"

          },

          "vip_qa": {

            "question_en": "What is the `content` property and in which context is it required?",

            "answer_en": "The `content` property is used with the `::before` and `::after` pseudo-elements to generate content. This property is **required** for these pseudo-elements to be rendered, even if the value is an empty string (`content: ''`)."

          }

        },

        {

          "id": 23,

          "level": "Advanced",

          "sub_topic": "Advanced Features",

          "question_en": "What are CSS Custom Properties (Variables)?",

          "question_bn": "CSS Custom Properties (ভ্যারিয়েবল) কী?",

          "details": {

            "what_is_en": "CSS Custom Properties are entities defined by CSS authors which contain specific values to be reused throughout a document, set using custom property notation (e.g., `--main-color: black;`).",

            "what_is_bn": "CSS Custom Properties হলো CSS-এর মধ্যে সংজ্ঞায়িত ভ্যারিয়েবল যা পুনঃব্যবহার করা যায়।"

          },

          "vip_qa": {

            "question_en": "What is a key advantage of CSS Custom Properties over pre-processor variables (like in Sass)?",

            "answer_en": "The key advantage is that CSS Custom Properties are **live and dynamic** in the browser's DOM and can be manipulated with JavaScript in real-time. Pre-processor variables are compiled into static CSS values before the browser receives the code."

          }

        },

        {

          "id": 24,

          "level": "Basic",

          "sub_topic": "Units",

          "question_en": "What is the difference between `rem` and `em` units?",

          "question_bn": "`rem` এবং `em` ইউনিটের মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "**`em`** is relative to the font-size of its direct parent element. **`rem`** (root em) is relative to the font-size of the root (`<html>`) element.",

            "what_is_bn": "**`em`** তার প্যারেন্ট এলিমেন্টের ফন্ট-সাইজের উপর নির্ভরশীল। **`rem`** রুট (`<html>`) এলিমেন্টের ফন্ট-সাইজের উপর নির্ভরশীল।"

          },

          "vip_qa": {

            "question_en": "Why is `rem` generally preferred for scalable and responsive typography?",

            "answer_en": "`rem` is preferred because it provides a consistent and predictable scaling reference point. You can scale the typography of the entire website up or down by simply changing the font-size on the `<html>` element, avoiding the compounding issues of nested `em` units."

          }

        },

        {

          "id": 25,

          "level": "Intermediate",

          "sub_topic": "Positioning",

          "question_en": "What is the difference between `position: absolute` and `position: fixed`?",

          "question_bn": "`position: absolute` এবং `position: fixed`-এর মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "**`position: absolute`** positions the element relative to its nearest *positioned* ancestor. **`position: fixed`** positions the element relative to the *viewport*, so it stays in the same place even when the page is scrolled.",

            "what_is_bn": "**`absolute`** তার নিকটতম পজিশনড প্যারেন্টের সাপেক্ষে অবস্থান করে। **`fixed`** ভিউপোর্টের সাপেক্ষে অবস্থান করে এবং স্ক্রল করলেও স্থির থাকে।"

          },

          "vip_qa": {

            "question_en": "What is a 'stacking context' and how is it related to the `z-index` property?",

            "answer_en": "A stacking context is a 3D conceptualization of HTML elements along a z-axis. A new stacking context is formed by elements with properties like `position: relative/absolute` and a `z-index`, or `opacity < 1`. An element's `z-index` only has meaning within its parent stacking context."

          }

        },

        {

          "id": 26,

          "level": "Advanced",

          "sub_topic": "Layout",

          "question_en": "What problem does `display: contents` solve?",

          "question_bn": "`display: contents` কী সমস্যার সমাধান করে?",

          "details": {

            "what_is_en": "`display: contents` causes an element to be removed from the DOM tree for layout purposes, but its child elements are kept. The element effectively disappears, and its children behave as if they are direct children of the element's parent.",

            "what_is_bn": "`display: contents` একটি এলিমেন্টকে লেআউট ট্রি থেকে সরিয়ে দেয়, কিন্তু তার চাইল্ড এলিমেন্টগুলো রেখে দেয়।"

          },

          "vip_qa": {

            "question_en": "Provide a practical use case for `display: contents` in a Flexbox or Grid layout.",

            "answer_en": "A great use case is when a semantic wrapper element is breaking your layout. Imagine a Flexbox container where you want all `<li>`s to be direct flex items, but some are wrapped in a `<div>`. Applying `display: contents` to the `<div>` removes it from the layout tree, and all `<li>`s become direct flex items, achieving the desired layout without sacrificing semantic HTML."

          }

        },

        {

          "id": 27,

          "level": "Intermediate",

          "sub_topic": "Responsive Design",

          "question_en": "What are media queries?",

          "question_bn": "মিডিয়া কোয়েরি কী?",

          "details": {

            "what_is_en": "Media queries are a CSS3 feature that allows you to apply different styles for different devices or conditions, such as screen width, height, or orientation.",

            "what_is_bn": "মিডিয়া কোয়েরি হলো একটি CSS3 ফিচার যা আপনাকে বিভিন্ন ডিভাইস বা শর্তের জন্য ভিন্ন স্টাইল প্রয়োগ করতে দেয়।"

          },

          "vip_qa": {

            "question_en": "What is the difference between a 'mobile-first' and 'desktop-first' approach?",

            "answer_en": "In a **'desktop-first'** approach, you write CSS for desktop and use `max-width` media queries for smaller screens. In a **'mobile-first'** approach, you write CSS for mobile and use `min-width` media queries for larger screens. **Mobile-first is the modern best practice** as it leads to cleaner, more performant CSS."

          }

        }

      ]

    },

    {

      "topic": "JavaScript",

      "questions": [

        {

          "id": 28,

          "level": "Basic",

          "sub_topic": "Variables and Data Types",

          "question_en": "What is the difference between `var`, `let`, and `const`?",

          "question_bn": "`var`, `let`, এবং `const` এর মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "`var` is function-scoped. `let` and `const` are block-scoped. `let` can be reassigned, but `const` cannot.",

            "what_is_bn": "`var` ফাংশন-স্কোপড। `let` এবং `const` ব্লক-স্কোপড। `let`-এর মান পরিবর্তন করা যায় কিন্তু `const`-এর যায় না।"

          },

          "vip_qa": {

            "question_en": "Explain the concept of the Temporal Dead Zone (TDZ) for `let` and `const`.",

            "answer_en": "The Temporal Dead Zone (TDZ) is the period between entering a block scope and the actual declaration of a `let` or `const` variable. While these variables are hoisted, they remain uninitialized. Accessing them during this 'dead zone' will result in a `ReferenceError`."

          }

        },

        {

          "id": 29,

          "level": "Intermediate",

          "sub_topic": "Functions and Scope",

          "question_en": "What is a Closure?",

          "question_bn": "Closure কী?",

          "details": {

            "what_is_en": "A closure is a function that remembers the variables from its outer scope, even after the outer function has finished executing.",

            "what_is_bn": "Closure হলো একটি ফাংশন যা তার বাইরের স্কোপের ভ্যারিয়েবলগুলোকে মনে রাখতে পারে।"

          },

          "vip_qa": {

            "question_en": "Describe a practical use case for closures in JavaScript, such as creating a private counter.",

            "answer_en": "A classic use case is to emulate private variables. A `createCounter` function can have a local `count` variable. The returned `increment` and `getValue` functions form closures over this scope, allowing them to access `count`, but the `count` variable itself cannot be accessed from outside, making it private."

          }

        },

        {

          "id": 30,

          "level": "Advanced",

          "sub_topic": "Asynchronous JavaScript",

          "question_en": "How does the Event Loop work?",

          "question_bn": "Event Loop কীভাবে কাজ করে?",

          "details": {

            "what_is_en": "The Event Loop allows JavaScript to perform non-blocking operations. It coordinates between the Call Stack, Web APIs, and the Callback Queue. When the Call Stack is empty, it pushes the first callback from the queue to the stack for execution.",

            "what_is_bn": "Event Loop একটি প্রক্রিয়া যা JavaScript-কে non-blocking আচরণ করতে সাহায্য করে।"

          },

          "vip_qa": {

            "question_en": "What is the difference between the Callback Queue (Macrotask) and the Microtask Queue?",

            "answer_en": "The **Callback Queue** holds callbacks for macrotasks like `setTimeout`. The **Microtask Queue** holds callbacks for microtasks, like `Promise` resolutions. The **Microtask Queue has higher priority** and will always be emptied completely before the Event Loop processes the next macrotask."

          }

        },

        {

          "id": 31,

          "level": "Basic",

          "sub_topic": "Data Types",

          "question_en": "What is the difference between `==` and `===`?",

          "question_bn": "`==` এবং `===` এর মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "**`==` (Loose Equality)** compares values after type conversion. **`===` (Strict Equality)** compares both value and type without type conversion.",

            "what_is_bn": "**`==`** টাইপ কনভার্সন করে মান তুলনা করে। **`===`** টাইপ এবং মান উভয়ই তুলনা করে।"

          },

          "vip_qa": {

            "question_en": "Can you explain Type Coercion and provide a tricky example?",

            "answer_en": "**Type Coercion** is the automatic conversion of values from one data type to another. A tricky example is `[] == ![]`, which evaluates to `true`. `![]` becomes `false`, which is coerced to `0`. `[]` is also coerced to `0`, making the comparison `0 == 0` true. This is why strict equality (`===`) is recommended."

          }

        },

        {

          "id": 32,

          "level": "Intermediate",

          "sub_topic": "Functions and Scope",

          "question_en": "What is Hoisting?",

          "question_bn": "Hoisting কী?",

          "details": {

            "what_is_en": "Hoisting is JavaScript's behavior of moving declarations to the top of their scope before code execution. Only declarations are hoisted, not initializations.",

            "what_is_bn": "Hoisting হলো JavaScript-এর একটি মেকানিজম যেখানে ডিক্লারেশনগুলো কোড এক্সিকিউশনের আগে তাদের স্কোপের শীর্ষে চলে আসে।"

          },

          "vip_qa": {

            "question_en": "Explain the difference in hoisting behavior between a function declaration and a function expression.",

            "answer_en": "A **function declaration** is fully hoisted (name and body). You can call it before it's declared. A **function expression** is not fully hoisted. If declared with `var`, only the variable name is hoisted and initialized with `undefined`, leading to a `TypeError`."

          }

        },

        {

          "id": 33,

          "level": "Advanced",

          "sub_topic": "Prototypes",

          "question_en": "What is Prototypal Inheritance?",

          "question_bn": "Prototypal Inheritance কী?",

          "details": {

            "what_is_en": "It's a mechanism where objects can inherit properties and methods from other objects. Every object has a link to a 'prototype' object, and the lookup for a property continues up the prototype chain.",

            "what_is_bn": "এটি একটি মেকানিজম যেখানে অবজেক্টগুলো একে অপরের কাছ থেকে প্রোপার্টি এবং মেথড ইনহেরিট করতে পারে।"

          },

          "vip_qa": {

            "question_en": "What is the difference between `__proto__` and `prototype`?",

            "answer_en": "**`prototype`** is a property on constructor functions that defines the prototype for its instances. **`__proto__`** is an internal property on every object instance that links to its prototype. In short: `prototype` is the blueprint; `__proto__` is the link to that blueprint."

          }

        },

        {

          "id": 34,

          "level": "Intermediate",

          "sub_topic": "The `this` keyword",

          "question_en": "What does the `this` keyword refer to?",

          "question_bn": "`this` কীওয়ার্ডটি কী বোঝায়?",

          "details": {

            "what_is_en": "`this` refers to the object it belongs to. Its value is determined by how a function is called.",

            "what_is_bn": "`this` একটি বিশেষ কীওয়ার্ড যা একটি ফাংশন যে অবজেক্টের কনটেক্সটে এক্সিকিউট হচ্ছে তাকে নির্দেশ করে।"

          },

          "vip_qa": {

            "question_en": "How does an arrow function handle `this` differently from a regular function?",

            "answer_en": "A **regular function** gets its own `this` context depending on how it's called. An **arrow function** does not have its own `this`; it lexically inherits `this` from its parent scope. This avoids the need to `bind(this)` in many cases."

          }

        },

        {

          "id": 35,

          "level": "Advanced",

          "sub_topic": "Asynchronous JavaScript",

          "question_en": "What is the difference between `Promise.all()` and `Promise.allSettled()`?",

          "question_bn": "`Promise.all()` এবং `Promise.allSettled()` এর মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "`Promise.all()` is fail-fast; it rejects if any promise rejects. `Promise.allSettled()` waits for all promises to either fulfill or reject and returns an array of their outcomes.",

            "what_is_bn": "`Promise.all()` যেকোনো একটি প্রমিজ রিজেক্ট হলেই ফেইল করে। `Promise.allSettled()` সব প্রমিজের ফলাফল (সফল বা ব্যর্থ) এর জন্য অপেক্ষা করে।"

          },

          "vip_qa": {

            "question_en": "Provide a scenario where `Promise.allSettled()` would be more appropriate than `Promise.all()`.",

            "answer_en": "Imagine you are fetching data from multiple independent, non-critical API endpoints to populate a dashboard. If one of these APIs fails, you still want to display the data from the ones that succeeded. Using `Promise.all()` would cause the entire operation to fail. `Promise.allSettled()` is perfect here because it will give you the results of all API calls, allowing you to gracefully handle the failed ones while still rendering the successful ones."

          }

        },

        {

          "id": 36,

          "level": "Intermediate",

          "sub_topic": "Array Methods",

          "question_en": "What is the difference between `forEach()` and `map()`?",

          "question_bn": "`forEach()` এবং `map()` এর মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "`map()` returns a new array containing the results of calling a function on every element. `forEach()` returns `undefined` and is used for executing a function for its side effects.",

            "what_is_bn": "`map()` একটি নতুন অ্যারে রিটার্ন করে। `forEach()` কিছুই রিটার্ন করে না এবং এটি শুধুমাত্র সাইড এফেক্টের জন্য ব্যবহৃত হয়।"

          },

          "vip_qa": {

            "question_en": "Why is it considered an anti-pattern to use `forEach` to create a new array?",

            "answer_en": "Using `forEach` with a `push` to an external array (`const newArr = []; arr.forEach(i => newArr.push(i * 2));`) is an anti-pattern because it's less readable and more verbose than using `map`. `map` is a declarative expression that clearly states the intent: 'transform this array into a new one'. `forEach` is imperative and focuses on the 'how' (looping and pushing), which can obscure the code's purpose."

          }

        },

        {

          "id": 37,

          "level": "Basic",

          "sub_topic": "ES6 Features",

          "question_en": "What is object destructuring?",

          "question_bn": "অবজেক্ট ডিস্ট্রাকচারিং কী?",

          "details": {

            "what_is_en": "Destructuring is an expression that makes it possible to unpack values from arrays, or properties from objects, into distinct variables.",

            "what_is_bn": "ডিস্ট্রাকচারিং হলো এমন একটি প্রক্রিয়া যা দিয়ে অ্যারে বা অবজেক্ট থেকে মানগুলোকে আলাদা ভ্যারিয়েবলে বের করে আনা যায়।"

          },

          "vip_qa": {

            "question_en": "How can you assign a new variable name and provide a default value during destructuring?",

            "answer_en": "To rename, use a colon (`:`). To provide a default value, use an equals sign (`=`). Example: `const { name: userName, age = 25 } = user;`. Here, `name` is unpacked into `userName`, and `age` defaults to `25` if not present in the `user` object."

          }

        }

      ]

    },

    {

      "topic": "React",

      "questions": [

        {

          "id": 38,

          "level": "Basic",

          "sub_topic": "Fundamentals",

          "question_en": "What is React?",

          "question_bn": "React কী?",

          "details": {

            "what_is_en": "React is a declarative, efficient, and flexible JavaScript library for building user interfaces, based on a component architecture.",

            "what_is_bn": "React একটি ডিক্লেয়ারেটিভ এবং ফ্লেক্সিবল জাভাস্ক্রিপ্ট লাইব্রেরি যা ইউজার ইন্টারফেস (UI) তৈরির জন্য ব্যবহৃত হয়।"

          },

          "vip_qa": {

            "question_en": "React is a 'library' not a 'framework'. What is the key distinction?",

            "answer_en": "The key distinction is 'inversion of control'. A **Framework** dictates your application's architecture and calls your code. A **Library** is a set of tools that you call. React is a library because it's focused on the UI layer and doesn't impose rules on routing or state management, giving developers more flexibility."

          }

        },

        {

          "id": 39,

          "level": "Intermediate",

          "sub_topic": "React Hooks",

          "question_en": "What is the `useEffect` Hook?",

          "question_bn": "`useEffect` হুক কী?",

          "details": {

            "what_is_en": "`useEffect` is a hook that lets you perform side effects in functional components, such as data fetching, subscriptions, or manually changing the DOM.",

            "what_is_bn": "`useEffect` একটি হুক যা ফাংশনাল কম্পোনেন্টে side effects পারফর্ম করার সুযোগ দেয়।"

          },

          "vip_qa": {

            "question_en": "Explain the purpose of the `useEffect` dependency array and the behavior for each case: 1) no array, 2) empty array `[]`, and 3) array with values `[dep]`.",

            "answer_en": "1) **No array**: The effect runs after every render. 2) **Empty array `[]`**: The effect runs only once, after the initial render. 3) **Array with values `[dep]`**: The effect runs after the initial render and re-runs only if any value in the array has changed."

          }

        },

        {

            "id": 40,

            "level": "Advanced",

            "sub_topic": "Performance Optimization",

            "question_en": "What is the difference between `useMemo` and `useCallback`?",

            "question_bn": "`useMemo` এবং `useCallback` হুকের মধ্যে পার্থক্য কী?",

            "details": {

              "what_is_en": "`useMemo` memoizes a value, while `useCallback` memoizes a function.",

              "what_is_bn": "`useMemo` একটি মানকে (value) memoize করে। `useCallback` একটি ফাংশনকে memoize করে।"

            },

            "vip_qa": {

              "question_en": "Why is wrapping every function in `useCallback` considered an anti-pattern?",

              "answer_en": "It's 'premature optimization'. `useCallback` has its own overhead. It should only be used when passing a function to a memoized child component (`React.memo`) to prevent unnecessary re-renders, or when the function is a dependency of another hook. Using it everywhere adds complexity and can even harm performance."

            }

        },

        {

            "id": 41,

            "level": "Basic",

            "sub_topic": "Fundamentals",

            "question_en": "What is JSX?",

            "question_bn": "JSX কী?",

            "details": {

                "what_is_en": "JSX (JavaScript XML) is a syntax extension for JavaScript that allows you to write HTML-like markup inside a JavaScript file.",

                "what_is_bn": "JSX হলো জাভাস্ক্রিপ্টের একটি সিনট্যাক্স এক্সটেনশন যা দিয়ে HTML-এর মতো কোড লেখা যায়।"

            },

            "vip_qa": {

                "question_en": "What is the difference between a React Element and a React Component?",

                "answer_en": "A **React Element** is a light, immutable object that describes what you want to see (e.g., `<p>Hello</p>`). A **React Component** is a function or a class that acts as a blueprint for elements. In short: a component *produces* elements."

            }

        },

        {

            "id": 42,

            "level": "Basic",

            "sub_topic": "Props and State",

            "question_en": "What is the difference between state and props?",

            "question_bn": "State এবং props এর মধ্যে পার্থক্য কী?",

            "details": {

                "what_is_en": "**Props** are read-only and passed from a parent to a child. **State** is a component's private, mutable data. A change in state triggers a re-render.",

                "what_is_bn": "**Props** প্যারেন্ট থেকে চাইল্ডে পাঠানো হয় এবং এটি রিড-অনলি। **State** একটি কম্পোনেন্টের নিজস্ব পরিবর্তনশীল ডেটা।"

            },

            "vip_qa": {

                "question_en": "What is 'prop drilling' and what are common solutions to avoid it?",

                "answer_en": "**Prop drilling** is passing props down through multiple layers of components that don't need them. **Solutions:** 1. **Context API** for global data. 2. **State Management Libraries (Redux, Zustand)** for complex state. 3. **Component Composition** by passing components as props."

            }

        },

        {

            "id": 43,

            "level": "Intermediate",

            "sub_topic": "Forms",

            "question_en": "What is the difference between a controlled and an uncontrolled component?",

            "question_bn": "কন্ট্রোলড এবং আনকন্ট্রোলড কম্পোনেন্টের মধ্যে পার্থক্য কী?",

            "details": {

                "what_is_en": "In a **controlled component**, form data is handled by React state. In an **uncontrolled component**, form data is handled by the DOM itself (using refs).",

                "what_is_bn": "**কন্ট্রোলড কম্পোনেন্টে**, ফর্ম ডেটা React state দ্বারা নিয়ন্ত্রিত হয়। **আনকন্ট্রোলড কম্পোনেন্টে**, ফর্ম ডেটা DOM নিজেই নিয়ন্ত্রণ করে।"

            },

            "vip_qa": {

                "question_en": "In what scenario might an uncontrolled component be a better choice?",

                "answer_en": "An uncontrolled component can be better when integrating with non-React code, on very simple forms, or for performance-critical forms with many inputs to avoid a state update on every keystroke. A file input (`<input type=\"file\">`) is inherently uncontrolled."

            }

        },

        {

            "id": 44,

            "level": "Intermediate",

            "sub_topic": "Lists and Keys",

            "question_en": "Why are `key`s important when rendering a list?",

            "question_bn": "লিস্ট রেন্ডার করার জন্য `key` কেন গুরুত্বপূর্ণ?",

            "details": {

                "what_is_en": "Keys help React identify which items have changed, are added, or are removed, optimizing the reconciliation process.",

                "what_is_bn": "`key` লিস্টের আইটেমগুলোকে শনাক্ত করতে React-কে সাহায্য করে, যা UI আপডেটকে অপ্টিমাইজ করে।"

            },

            "vip_qa": {

                "question_en": "Why is it a bad practice to use an array's index as a `key` if the list is dynamic?",

                "answer_en": "Using an index as a key is an anti-pattern for dynamic lists. If you delete the first item, the second item becomes the first, inheriting `key={0}`. React thinks the element just changed its content, which can lead to incorrect DOM updates and buggy behavior, especially if list items have their own state."

            }

        },

        {

            "id": 45,

            "level": "Advanced",

            "sub_topic": "Advanced Hooks",

            "question_en": "What is the `useReducer` hook?",

            "question_bn": "`useReducer` হুক কী?",

            "details": {

                "what_is_en": "`useReducer` is an alternative to `useState` for managing more complex state logic.",

                "what_is_bn": "`useReducer` হলো `useState`-এর একটি বিকল্প যা জটিল state লজিক ম্যানেজ করতে ব্যবহৃত হয়।"

            },

            "vip_qa": {

                "question_en": "When would you choose `useReducer` over `useState`?",

                "answer_en": "Choose `useReducer` for: 1. **Complex State Shape:** When state is an object with multiple properties that change together. 2. **Complex State Transitions:** When the logic for updating state is complex. 3. **Inter-related State:** When changing one piece of state requires changing another. `useReducer` centralizes this logic."

            }

        },

        {

            "id": 46,

            "level": "Advanced",

            "sub_topic": "Advanced Patterns",

            "question_en": "What is a Custom Hook?",

            "question_bn": "কাস্টম হুক কী?",

            "details": {

                "what_is_en": "A Custom Hook is a JavaScript function whose name starts with 'use' and that can call other Hooks. It's a way to extract and reuse stateful logic.",

                "what_is_bn": "কাস্টম হুক হলো একটি জাভাস্ক্রিপ্ট ফাংশন যার নাম 'use' দিয়ে শুরু হয় এবং এটি stateful লজিক পুনঃব্যবহার করার একটি উপায়।"

            },

            "vip_qa": {

                "question_en": "What are the advantages of Custom Hooks over HOCs and Render Props?",

                "answer_en": "Custom Hooks offer significant advantages: 1. **No 'Wrapper Hell':** They don't add extra component layers to the tree. 2. **More Explicit:** You explicitly call the hook and destructure values, making data flow clearer. 3. **Better Composability:** You can use multiple hooks in one component without nesting issues."

            }

        },

        {

            "id": 47,

            "level": "Basic",

            "sub_topic": "State Management",

            "question_en": "How do you lift state up in React?",

            "question_bn": "React-এ state কীভাবে 'lift up' করা হয়?",

            "details": {

                "what_is_en": "'Lifting state up' is moving state from a child to its closest common ancestor when multiple children need to share that state.",

                "what_is_bn": "যখন একাধিক চাইল্ড কম্পোনেন্টের মধ্যে state শেয়ার করার প্রয়োজন হয়, তখন সেই state-কে তাদের নিকটতম কমন প্যারেন্টে স্থানান্তর করাকে 'lifting state up' বলে।"

            },

            "vip_qa": {

                "question_en": "What is the typical data flow in React after lifting state up?",

                "answer_en": "The data flow becomes **unidirectional** or **one-way**. The state lives in the parent. The parent passes state down to children as props. If a child needs to update the state, the parent passes a callback function down as a prop, which the child calls. This makes the application's logic more predictable."

            }

        }

      ]

    },

    {

      "topic": "Next.js",

      "questions": [

        {

          "id": 48,

          "level": "Intermediate",

          "sub_topic": "Fundamentals",

          "question_en": "What is Next.js?",

          "question_bn": "Next.js কী?",

          "details": {

            "what_is_en": "Next.js is a production-ready React framework that enables features like Server-Side Rendering (SSR) and Static Site Generation (SSG).",

            "what_is_bn": "Next.js হলো React-এর উপর ভিত্তি করে তৈরি একটি প্রোডাকশন-রেডি ফ্রেমওয়ার্ক।"

          },

          "vip_qa": {

            "question_en": "What is the difference between a CSR React app and a Next.js SSR app?",

            "answer_en": "In a CSR app, the browser gets an empty HTML file and renders content after the JS bundle loads. In an SSR app, the server generates the full HTML and sends it to the browser, so the user sees content almost immediately. This is better for SEO and perceived performance."

          }

        },

        {

          "id": 49,

          "level": "Advanced",

          "sub_topic": "Data Fetching",

          "question_en": "What is the difference between `getStaticProps` and `getServerSideProps`?",

          "question_bn": "`getStaticProps` এবং `getServerSideProps` এর মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "`getStaticProps` fetches data at build time for SSG. `getServerSideProps` fetches data on each request for SSR.",

            "what_is_bn": "`getStaticProps` বিল্ড টাইমে ডেটা ফেচ করে (SSG)। `getServerSideProps` প্রতিটি রিকোয়েস্টের সময় সার্ভারে ডেটা ফেচ করে (SSR)।"

          },

          "vip_qa": {

            "question_en": "What is Incremental Static Regeneration (ISR)?",

            "answer_en": "ISR allows you to update static pages *after* the site has been built. By adding a `revalidate` property to `getStaticProps`, you tell Next.js to serve the cached page but re-generate it in the background if a request comes in after the revalidation period. It combines the speed of static with the freshness of dynamic."

          }

        },

        {

          "id": 50,

          "level": "Advanced",

          "sub_topic": "App Router",

          "question_en": "What are React Server Components (RSCs)?",

          "question_bn": "React Server Components (RSC) কী?",

          "details": {

            "what_is_en": "RSCs are a new type of component that runs exclusively on the server and never ships JavaScript to the client. This reduces bundle size and allows direct backend access.",

            "what_is_bn": "RSC হলো এমন কম্পোনেন্ট যা শুধুমাত্র সার্ভারে রান হয় এবং ক্লায়েন্টে কোনো JavaScript পাঠায় না।"

          },

          "vip_qa": {

            "question_en": "How do you fetch data in a Server Component?",

            "answer_en": "You can simply use `async/await` directly within the component to fetch data. There is no need for special functions like `getServerSideProps`. The component itself becomes the unit of data fetching."

          }

        },

        {

          "id": 51,

          "level": "Intermediate",

          "sub_topic": "Routing",

          "question_en": "What are Dynamic Routes in Next.js?",

          "question_bn": "Next.js-এ Dynamic Routes কী?",

          "details": {

            "what_is_en": "Dynamic Routes allow you to create pages from dynamic data by using a file or folder name wrapped in square brackets, like `[id]`.",

            "what_is_bn": "ডাইনামিক রাউট আপনাকে পরিবর্তনশীল ডেটা থেকে পেজ তৈরি করতে দেয়। ফাইলের নাম ব্র্যাকেটের মধ্যে রেখে (`[id]`) ডাইনামিক সেগমেন্ট তৈরি করা হয়।"

          },

          "vip_qa": {

            "question_en": "Explain the role of the `fallback` property in `getStaticPaths`.",

            "answer_en": "The `fallback` property controls behavior for paths not pre-rendered at build time: **`false`** returns a 404. **`true`** serves a fallback UI while regenerating the page in the background (ISR). **`'blocking'`** server-renders the page on the first request and caches it, with no fallback UI."

          }

        },

        {

          "id": 52,

          "level": "Advanced",

          "sub_topic": "Features",

          "question_en": "What are API Routes in Next.js?",

          "question_bn": "Next.js-এ API Routes কী?",

          "details": {

            "what_is_en": "API Routes allow you to create a backend API endpoint as part of your Next.js application, inside the `pages/api` directory.",

            "what_is_bn": "`pages/api` ডিরেক্টরির ভেতরের যেকোনো ফাইল একটি API এন্ডপয়েন্ট হিসেবে কাজ করে।"

          },

          "vip_qa": {

            "question_en": "When would you use Next.js API Routes versus a separate backend server?",

            "answer_en": "Use **Next.js API Routes** for simpler tasks tied to your frontend (form submissions, auth). Build a **separate backend** for complex, data-intensive backends, or when you need to serve multiple clients (web, mobile)."

          }

        },

        {

          "id": 53,

          "level": "Advanced",

          "sub_topic": "App Router",

          "question_en": "What is the difference between a Client Component and a Server Component?",

          "question_bn": "Client Component এবং Server Component এর মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "**Server Components** run only on the server with zero client-side JS. **Client Components** (`'use client'`) are interactive and render on the client.",

            "what_is_bn": "**Server Component** শুধুমাত্র সার্ভারে রান হয়। **Client Component** (`'use client'`) ক্লায়েন্টে রেন্ডার হয়।"

          },

          "vip_qa": {

            "question_en": "Explain the pattern of 'passing server components to client components as props'.",

            "answer_en": "You **cannot** import a Server Component into a Client Component. However, you **can** pass a Server Component as a `prop` (specifically `children`) to a Client Component. This allows you to 'slot' server-rendered content inside an interactive client-side layout, giving you the best of both worlds."

          }

        }

      ]

    },

    {

      "topic": "TypeScript",

      "questions": [

        {

          "id": 54,

          "level": "Intermediate",

          "sub_topic": "Fundamentals",

          "question_en": "What is TypeScript?",

          "question_bn": "TypeScript কী?",

          "details": {

            "what_is_en": "TypeScript is a statically typed superset of JavaScript that compiles to plain JavaScript.",

            "what_is_bn": "TypeScript হলো JavaScript-এর একটি স্ট্যাটিক্যালি টাইপড সুপারসেট।"

          },

          "vip_qa": {

            "question_en": "What is the difference between an `interface` and a `type` alias?",

            "answer_en": "An **`interface`** is primarily for defining object shapes and supports declaration merging. A **`type`** alias is more versatile (can define unions, tuples, etc.) but does not support merging. Use `interface` for object shapes, `type` for everything else."

          }

        },

        {

          "id": 55,

          "level": "Intermediate",

          "sub_topic": "Types",

          "question_en": "What are Generics in TypeScript?",

          "question_bn": "TypeScript-এ Generics কী?",

          "details": {

            "what_is_en": "Generics allow you to create reusable components, functions, or classes that can work with a variety of types while maintaining type safety.",

            "what_is_bn": "Generics আপনাকে পুনঃব্যবহারযোগ্য এবং টাইপ-সেফ কোড লিখতে দেয় যা বিভিন্ন ধরনের ডেটা নিয়ে কাজ করতে পারে।"

          },

          "vip_qa": {

            "question_en": "Provide an example of a generic function and explain why it's better than using `any`.",

            "answer_en": "A generic function maintains the relationship between input and output types: `function getFirst<T>(arr: T[]): T { return arr[0]; }`. If you call `getFirst([1, 2])`, TS knows the return type is `number`. If you used `any`, TS would lose all type information. Generics provide reusability without sacrificing type safety."

          }

        },

        {

          "id": 56,

          "level": "Advanced",

          "sub_topic": "Utility Types",

          "question_en": "What are Utility Types in TypeScript?",

          "question_bn": "TypeScript-এ Utility Types কী?",

          "details": {

            "what_is_en": "Utility Types are built-in type helpers that facilitate common type transformations.",

            "what_is_bn": "Utility Types হলো বিল্ট-ইন টাইপ যা বিদ্যমান টাইপগুলোকে রূপান্তরিত করে নতুন টাইপ তৈরি করতে সাহায্য করে।"

          },

          "vip_qa": {

            "question_en": "Explain the use cases for `Partial<T>`, `Pick<T, K>`, and `Omit<T, K>`.",

            "answer_en": "**`Partial<T>`:** Makes all properties of `T` optional (useful for update functions). **`Pick<T, K>`:** Creates a type by picking a set of properties `K` from `T` (useful for creating a smaller preview version). **`Omit<T, K>`:** Creates a type by removing properties `K` from `T` (useful for removing sensitive info)."

          }

        },

        {

          "id": 57,

          "level": "Basic",

          "sub_topic": "Types",

          "question_en": "What is the difference between `any` and `unknown`?",

          "question_bn": "`any` এবং `unknown` এর মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "**`any`** turns off type checking. **`unknown`** is a type-safe counterpart; you must perform a type check or assertion before you can operate on an `unknown` value.",

            "what_is_bn": "**`any`** টাইপ চেকিং বন্ধ করে দেয়। **`unknown`** হলো `any`-এর একটি টাইপ-সেফ বিকল্প।"

          },

          "vip_qa": {

            "question_en": "Why is it recommended to use `unknown` instead of `any` for API responses?",

            "answer_en": "Using `unknown` forces you to write safer code. With `any`, you can access any property (`myAnyVar.foo()`) which can lead to runtime errors. With `unknown`, TypeScript will throw a compile-time error. It forces you to explicitly check the type before working with it, preventing potential bugs."

          }

        }

      ]

    },

    {

      "topic": "TailwindCSS",

      "questions": [

        {

          "id": 58,

          "level": "Basic",

          "sub_topic": "Fundamentals",

          "question_en": "What is TailwindCSS?",

          "question_bn": "TailwindCSS কী?",

          "details": {

            "what_is_en": "TailwindCSS is a utility-first CSS framework that provides low-level utility classes to build custom designs directly in your markup.",

            "what_is_bn": "TailwindCSS একটি utility-first CSS ফ্রেমওয়ার্ক।"

          },

          "vip_qa": {

            "question_en": "What are the main criticisms of utility-first CSS, and the counter-arguments?",

            "answer_en": "Criticism: It makes HTML 'messy'. Counter-argument: This is encapsulated in reusable components. Criticism: It's 'just inline styles'. Counter-argument: It uses a constrained design system and supports states and responsive design, which inline styles cannot."

          }

        },

        {

          "id": 59,

          "level": "Intermediate",

          "sub_topic": "Configuration",

          "question_en": "What is the purpose of `@apply`?",

          "question_bn": "`@apply` এর কাজ কী?",

          "details": {

            "what_is_en": "The `@apply` directive lets you extract and reuse utility classes by composing them into a custom CSS class.",

            "what_is_bn": "`@apply` ডাইরেক্টিভ দিয়ে একাধিক ইউটিলিটি ক্লাসকে একটি কাস্টম ক্লাসে আনা যায়।"

          },

          "vip_qa": {

            "question_en": "Why do many advise against overusing `@apply`?",

            "answer_en": "Overusing `@apply` can recreate the problem Tailwind aims to solve: building a large, abstract CSS file. The recommended alternative is to create abstractions at the component level (e.g., a React `<Button>` component). This keeps utilities co-located with the markup."

          }

        },

        {

          "id": 60,

          "level": "Intermediate",

          "sub_topic": "Configuration",

          "question_en": "How do you customize Tailwind's design system?",

          "question_bn": "Tailwind-এর ডিজাইন সিস্টেম কীভাবে কাস্টমাইজ করবেন?",

          "details": {

            "what_is_en": "You customize it through the `tailwind.config.js` file, using the `theme.extend` object to add new values or override existing ones.",

            "what_is_bn": "`tailwind.config.js` ফাইলের `theme.extend` অবজেক্ট ব্যবহার করে এটি কাস্টমাইজ করা হয়।"

          },

          "vip_qa": {

            "question_en": "What is the difference between placing customizations in `theme` vs `theme.extend`?",

            "answer_en": "Placing customizations directly in `theme` will **completely replace** Tailwind's defaults for that key. Placing them in `theme.extend` will **add to or override** the defaults. Using `extend` is almost always the recommended approach."

          }

        },

        {

          "id": 61,

          "level": "Advanced",

          "sub_topic": "JIT Compiler",

          "question_en": "What is the Just-In-Time (JIT) Compiler in Tailwind?",

          "question_bn": "Tailwind-এ Just-In-Time (JIT) Compiler কী?",

          "details": {

            "what_is_en": "The JIT compiler is an engine that generates your CSS on-demand by scanning your template files for classes.",

            "what_is_bn": "JIT কম্পাইলার আপনার টেমপ্লেট ফাইল স্ক্যান করে শুধুমাত্র আপনার ব্যবহৃত ক্লাসগুলোর জন্য CSS তৈরি করে।"

          },

          "vip_qa": {

            "question_en": "What are the three main benefits of the JIT compiler?",

            "answer_en": "1. **Fast Build Times.** 2. **Arbitrary Value Support:** You can use values not in your theme directly in your HTML (e.g., `w-[321px]`). 3. **All Variants Enabled:** All variants (like `focus-visible`, `disabled`) are enabled by default without increasing build size."

          }

        },

        {

          "id": 62,

          "level": "Intermediate",

          "sub_topic": "Component Libraries",

          "question_en": "What is DaisyUI?",

          "question_bn": "DaisyUI কী?",

          "details": {

            "what_is_en": "DaisyUI is a plugin for Tailwind CSS that provides pre-built component classes like `btn`, `card`, etc.",

            "what_is_bn": "DaisyUI হলো Tailwind CSS-এর জন্য একটি প্লাগইন যা `btn`, `card`-এর মতো কম্পোনেন্ট ক্লাস সরবরাহ করে।"

          },

          "vip_qa": {

            "question_en": "How does DaisyUI achieve theming with utility classes?",

            "answer_en": "DaisyUI uses CSS Custom Properties (variables) for its component colors. When you apply a theme (e.g., `data-theme=\"cupcake\"`), it sets a series of CSS variables. DaisyUI's component classes then use these variables (`background-color: var(--p)`), allowing for easy theming while leveraging Tailwind's core."

          }

        }

      ]

    },

    {

      "topic": "Node.js",

      "questions": [

        {

          "id": 63,

          "level": "Basic",

          "sub_topic": "Fundamentals",

          "question_en": "Why is Node.js single-threaded yet performant?",

          "question_bn": "Node.js কেন Single-Threaded হওয়া সত্ত্বেও পারফরম্যান্ট?",

          "details": {

            "what_is_en": "Node.js uses a single-threaded, non-blocking, asynchronous I/O model. Its Event Loop offloads I/O operations, allowing the main thread to handle other requests without being blocked.",

            "what_is_bn": "Node.js একটি single-threaded, non-blocking, asynchronous I/O মডেল ব্যবহার করে।"

          },

          "vip_qa": {

            "question_en": "For what type of application would Node.js be a poor choice, and why?",

            "answer_en": "Node.js would be a poor choice for **CPU-bound applications** (e.g., video encoding). A long-running, synchronous, CPU-intensive task will block the single main thread, making the server completely unresponsive."

          }

        },

        {

          "id": 64,

          "level": "Advanced",

          "sub_topic": "Event Loop",

          "question_en": "What are the different phases of the Node.js Event Loop?",

          "question_bn": "Node.js Event Loop-এর বিভিন্ন Phase-গুলো কী কী?",

          "details": {

            "what_is_en": "The Event Loop consists of several phases that run in a cycle: Timers, Pending Callbacks, Poll, Check, and Close Callbacks.",

            "what_is_bn": "Event Loop কয়েকটি Phase-এর একটি চক্র যা নির্দিষ্ট ক্রমে এক্সিকিউট হয়।"

          },

          "vip_qa": {

            "question_en": "What is the difference between `setImmediate()`, `setTimeout(() => {}, 0)`, and `process.nextTick()`?",

            "answer_en": "`process.nextTick()` is not part of the Event Loop and has the highest priority. `setTimeout(0)` schedules a callback for the Timers phase. `setImmediate()` schedules a callback for the Check phase. Typically, `nextTick` runs first, then microtasks, then `setTimeout`, then `setImmediate`."

          }

        },

        {

          "id": 65,

          "level": "Intermediate",

          "sub_topic": "Modules",

          "question_en": "What is the difference between CommonJS and ES Modules?",

          "question_bn": "CommonJS এবং ES Modules এর মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "**CommonJS** (`require`) is synchronous. **ES Modules** (`import`) are asynchronous and are the official standard.",

            "what_is_bn": "**CommonJS** সিঙ্ক্রোনাস। **ES Modules** অ্যাসিঙ্ক্রোনাস এবং এটি এখন স্ট্যান্ডার্ড।"

          },

          "vip_qa": {

            "question_en": "How can you use ES Modules in a traditional Node.js project?",

            "answer_en": "1. Add `\"type\": \"module\"` to your `package.json`. 2. Use the `.mjs` file extension for modules."

          }

        },

        {

          "id": 66,

          "level": "Intermediate",

          "sub_topic": "Core Modules",

          "question_en": "What are Streams in Node.js?",

          "question_bn": "Node.js-এ Streams কী?",

          "details": {

            "what_is_en": "Streams are objects that let you read or write data in continuous chunks, which is efficient for large data.",

            "what_is_bn": "Streams হলো অবজেক্ট যা আপনাকে বড় ডেটাকে খণ্ডে খণ্ডে পড়তে বা লিখতে দেয়।"

          },

          "vip_qa": {

            "question_en": "What is the benefit of using `stream.pipe()`?",

            "answer_en": "The `pipe()` method connects a readable stream to a writable stream. Its main benefit is that it automatically handles **backpressure**, pausing the readable stream if the writable stream is slow, thus preventing memory overflows."

          }

        },

        {

          "id": 67,

          "level": "Advanced",

          "sub_topic": "Advanced Concepts",

          "question_en": "What are worker threads in Node.js?",

          "question_bn": "Node.js-এ worker threads কী?",

          "details": {

            "what_is_en": "The `worker_threads` module allows you to run JavaScript code in parallel on separate threads, useful for CPU-intensive tasks.",

            "what_is_bn": "`worker_threads` মডিউল আপনাকে সমান্তরালভাবে আলাদা থ্রেডে জাভাস্ক্রিপ্ট কোড চালানোর সুযোগ দেয়।"

          },

          "vip_qa": {

            "question_en": "How does a worker thread differ from `child_process.fork()`?",

            "answer_en": "**`child_process.fork()`** creates a new Node.js process. **`worker_threads`** operate within the same process and can share memory, making them much more lightweight and efficient for CPU-bound tasks."

          }

        }

      ]

    },

    {

      "topic": "Express.js",

      "questions": [

        {

          "id": 68,

          "level": "Intermediate",

          "sub_topic": "Middleware",

          "question_en": "What is middleware in Express.js?",

          "question_bn": "Express.js-এ মিডলওয়্যার কী?",

          "details": {

            "what_is_en": "Middleware is a function with access to the request (`req`), response (`res`), and `next()` function, which can execute code or modify the request-response cycle.",

            "what_is_bn": "মিডলওয়্যার হলো এমন একটি ফাংশন যা একটি HTTP রিকোয়েস্ট এবং রেসপন্স সাইকেলের মধ্যে অবস্থান করে।"

          },

          "vip_qa": {

            "question_en": "What is the purpose of `express.Router()`?",

            "answer_en": "`express.Router()` creates a modular route handler. It allows you to group related routes into separate files (e.g., `userRoutes.js`) and then mount them on a path in your main app file (`app.use('/users', userRoutes)`), keeping your code organized."

          }

        },

        {

          "id": 69,

          "level": "Basic",

          "sub_topic": "Routing",

          "question_en": "How do you handle route parameters in Express?",

          "question_bn": "Express-এ রাউট প্যারামিটার কীভাবে হ্যান্ডেল করবেন?",

          "details": {

            "what_is_en": "Route parameters are URL segments defined with a colon (`:`). For a route like `/users/:id`, the ID can be accessed via `req.params.id`.",

            "what_is_bn": "রাউট প্যারামিটার হলো URL-এর পরিবর্তনশীল অংশ যা কোলন (`:`) দিয়ে ডিফাইন করা হয় এবং `req.params.id` দিয়ে অ্যাক্সেস করা যায়।"

          },

          "vip_qa": {

            "question_en": "What is the difference between `req.params`, `req.query`, and `req.body`?",

            "answer_en": "**`req.params`** contains route parameters (e.g., `/users/:id`). **`req.query`** contains query string parameters (e.g., `/search?term=node`). **`req.body`** contains the payload of an incoming request (e.g., from a POST form)."

          }

        },

        {

          "id": 70,

          "level": "Advanced",

          "sub_topic": "Error Handling",

          "question_en": "How do you implement centralized error handling in Express?",

          "question_bn": "Express-এ কেন্দ্রীয়ভাবে এরর হ্যান্ডেলিং কীভাবে করবেন?",

          "details": {

            "what_is_en": "By defining a special error-handling middleware with four arguments: `(err, req, res, next)`. This must be defined after all other routes.",

            "what_is_bn": "এরর-হ্যান্ডেলিং মিডলওয়্যার ফাংশন দিয়ে এটি করা হয়, যার চারটি আর্গুমেন্ট (`err, req, res, next`) থাকে।"

          },

          "vip_qa": {

            "question_en": "In an async route handler, why must you call `next(error)`?",

            "answer_en": "Express cannot automatically catch errors in asynchronous code. If an error occurs in an async operation, you must catch it and explicitly pass it to Express's error-handling middleware by calling `next(error)`, otherwise the request will hang."

          }

        }

      ]

    },

    {

      "topic": "MongoDB",

      "questions": [

        {

          "id": 71,

          "level": "Intermediate",

          "sub_topic": "Mongoose and Schemas",

          "question_en": "What is Mongoose?",

          "question_bn": "Mongoose কী?",

          "details": {

            "what_is_en": "Mongoose is an Object Data Modeling (ODM) library for MongoDB and Node.js.",

            "what_is_bn": "Mongoose হলো MongoDB এবং Node.js-এর জন্য একটি Object Data Modeling (ODM) লাইব্রেরি।"

          },

          "vip_qa": {

            "question_en": "What is the difference between embedding and referencing documents?",

            "answer_en": "**Embedding:** You store related data within a single document. **Pros:** Fast reads. **Cons:** Data redundancy. **Referencing:** You store references (`ObjectId`) to documents in other collections. **Pros:** Reduces redundancy. **Cons:** Requires extra queries (`populate` or `$lookup`)."

          }

        },

        {

          "id": 72,

          "level": "Advanced",

          "sub_topic": "Aggregation",

          "question_en": "What is the MongoDB Aggregation Pipeline?",

          "question_bn": "MongoDB Aggregation Pipeline কী?",

          "details": {

            "what_is_en": "It's a framework for data aggregation where documents pass through a multi-stage pipeline that transforms them into an aggregated result.",

            "what_is_bn": "এটি একটি ফ্রেমওয়ার্ক যা একাধিক ধাপে ডেটা প্রসেস করে একটি গণনা করা ফলাফল প্রদান করে।"

          },

          "vip_qa": {

            "question_en": "Why use the Aggregation Framework's `$lookup` stage instead of Mongoose's `populate()`?",

            "answer_en": "For performance. `populate()` can cause the 'N+1 query problem'. `$lookup` performs the join on the database server itself, returning all data in a single, highly efficient query."

          }

        },

        {

          "id": 73,

          "level": "Advanced",

          "sub_topic": "Indexing",

          "question_en": "What is an index in MongoDB?",

          "question_bn": "MongoDB-তে Index কী?",

          "details": {

            "what_is_en": "An index is a special data structure that improves query performance.",

            "what_is_bn": "Index হলো একটি বিশেষ ডেটা স্ট্রাকচার যা কোয়েরির পারফরম্যান্স বাড়ায়।"

          },

          "vip_qa": {

            "question_en": "What is a compound index and why does the order of fields matter?",

            "answer_en": "A **compound index** is an index on multiple fields. The order matters because the query must include the prefix fields of the index to be efficient. An index on `{ userid: 1, score: -1 }` cannot efficiently support a query that only filters on `score`."

          }

        },

        {

          "id": 74,

          "level": "Basic",

          "sub_topic": "Concepts",

          "question_en": "What is the difference between a collection and a document?",

          "question_bn": "কালেকশন এবং ডকুমেন্টের মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "A **document** is a single BSON record. A **collection** is a group of documents, equivalent to a table in a relational database.",

            "what_is_bn": "**ডকুমেন্ট** হলো একটি একক রেকর্ড। **কালেকশন** হলো ডকুমেন্টের একটি গ্রুপ।"

          },

          "vip_qa": {

            "question_en": "Does a collection enforce a schema?",

            "answer_en": "By default, MongoDB collections have a **dynamic schema**. However, you can enforce a rigid schema at the application level using an ODM like Mongoose or using MongoDB's built-in schema validation."

          }

        },

        {

          "id": 75,

          "level": "Intermediate",

          "sub_topic": "Mongoose",

          "question_en": "What are Mongoose middleware (hooks)?",

          "question_bn": "Mongoose Middleware (Hooks) কী?",

          "details": {

            "what_is_en": "Mongoose hooks are functions passed control during the execution of async functions like `save`, `validate`, etc.",

            "what_is_bn": "Mongoose Hooks হলো এমন ফাংশন যা ডেটা লাইফসাইকেলের নির্দিষ্ট ধাপে স্বয়ংক্রিয়ভাবে রান হয়।"

          },

          "vip_qa": {

            "question_en": "What is the difference between `pre('save')` and `post('save')` middleware?",

            "answer_en": "**`pre('save')`** runs **before** a document is saved and is perfect for data preparation, like hashing a password. **`post('save')`** runs **after** a successful save and is ideal for follow-up actions, like sending a welcome email."

          }

        }

      ]

    },

    {

      "topic": "Git & GitHub",

      "questions": [

        {

          "id": 76,

          "level": "Intermediate",

          "sub_topic": "Branching and Merging",

          "question_en": "What is a merge conflict?",

          "question_bn": "Merge Conflict কী?",

          "details": {

            "what_is_en": "A merge conflict occurs when Git cannot automatically resolve differences in code between two commits.",

            "what_is_bn": "Merge Conflict তখন ঘটে যখন Git দুটি ভিন্ন ব্রাঞ্চের পরিবর্তনগুলোকে স্বয়ংক্রিয়ভাবে একত্রিত করতে পারে না।"

          },

          "vip_qa": {

            "question_en": "What is the difference between `git merge` and `git rebase`?",

            "answer_en": "`git merge` integrates changes by creating a new 'merge commit', preserving history. `git rebase` re-applies commits on top of another branch, creating a linear history but rewriting it. Never rebase a public, shared branch."

          }

        },

        {

          "id": 77,

          "level": "Advanced",

          "sub_topic": "History Management",

          "question_en": "What is the difference between `git reset` and `git revert`?",

          "question_bn": "`git reset` এবং `git revert`-এর মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "`git reset` moves the HEAD pointer, erasing commits. `git revert` undoes a commit by creating a new commit.",

            "what_is_bn": "`git reset` কমিট হিস্ট্রিকে পেছনের দিকে নিয়ে যায়। `git revert` একটি কমিটকে আনডু করার জন্য একটি নতুন কমিট তৈরি করে।"

          },

          "vip_qa": {

            "question_en": "Which command, `reset` or `revert`, is safer on a shared branch and why?",

            "answer_en": "`git revert` is safer. `git reset` rewrites history, which is destructive on a shared branch. `git revert` is non-destructive; it appends a new commit, making it the correct choice for public branches."

          }

        },

        {

          "id": 78,

          "level": "Basic",

          "sub_topic": "Core Concepts",

          "question_en": "What is the difference between Git and GitHub?",

          "question_bn": "Git এবং GitHub এর মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "**Git** is the version control system software. **GitHub** is a cloud-based hosting service for Git repositories.",

            "what_is_bn": "**Git** হলো একটি ভার্সন কন্ট্রোল সিস্টেম সফটওয়্যার। **GitHub** হলো Git রিপোজিটরিগুলোর জন্য একটি ক্লাউড-ভিত্তিক হোস্টিং সার্ভিস।"

          },

          "vip_qa": {

            "question_en": "Can you use Git without GitHub?",

            "answer_en": "Yes, absolutely. Git is a completely independent tool that you can use entirely on your local machine. Services like GitHub make collaborating with others and managing remote backups easier."

          }

        },

        {

          "id": 79,

          "level": "Intermediate",

          "sub_topic": "Commands",

          "question_en": "What does `git stash` do?",

          "question_bn": "`git stash` কী কাজ করে?",

          "details": {

            "what_is_en": "`git stash` temporarily shelves your modified files, allowing you to switch contexts.",

            "what_is_bn": "`git stash` আপনার পরিবর্তন করা ফাইলগুলোকে একটি স্ট্যাকে সাময়িকভাবে সংরক্ষণ করে।"

          },

          "vip_qa": {

            "question_en": "Describe a common workflow where `git stash` is very useful.",

            "answer_en": "When you are working on a feature and an urgent bug fix is required on `main`. Your work is not ready to be committed. `git stash` your changes, switch to `main`, fix the bug, and then return to your feature branch and `git stash pop` to reapply your work."

          }

        },

        {

          "id": 80,

          "level": "Basic",

          "sub_topic": "Workflow",

          "question_en": "What is the basic Git workflow?",

          "question_bn": "বেসিক Git ওয়ার্কফ্লো কী?",

          "details": {

            "what_is_en": "Modify files, `git add` to stage changes, `git commit` to save to local repo, and `git push` to share with a remote repo.",

            "what_is_bn": "ফাইল পরিবর্তন করা, `git add`, `git commit`, এবং `git push`।"

          },

          "vip_qa": {

            "question_en": "What is the difference between the Working Directory, Staging Area, and Repository?",

            "answer_en": "1. **Working Directory:** Your current project folder. 2. **Staging Area:** An intermediate area where you prepare changes for the next commit. 3. **Repository (.git):** Where Git permanently stores all committed snapshots of your project."

          }

        }

      ]

    },

    {

      "topic": "Development Tools & Workflow",

      "questions": [

        {

          "id": 81,

          "level": "Intermediate",

          "sub_topic": "API Testing",

          "question_en": "What is Postman?",

          "question_bn": "Postman কী?",

          "details": {

            "what_is_en": "Postman is an API platform for building and using APIs, simplifying the API lifecycle.",

            "what_is_bn": "Postman একটি API টেস্টিং এবং ডেভেলপমেন্ট টুল।"

          },

          "vip_qa": {

            "question_en": "What are Postman 'Collections' and 'Environments'?",

            "answer_en": "**Collections** are groups of saved API requests. **Environments** are sets of key-value variables. Using them together allows you to run the same tests against different servers (dev, staging) by just switching the environment."

          }

        },

        {

          "id": 82,

          "level": "Intermediate",

          "sub_topic": "Project Management",

          "question_en": "What is Jira?",

          "question_bn": "Jira কী?",

          "details": {

            "what_is_en": "Jira is a project management and issue tracking tool for software teams using Agile methodologies.",

            "what_is_bn": "Jira হলো একটি জনপ্রিয় প্রজেক্ট ম্যানেজমেন্ট এবং ইস্যু ট্র্যাকিং টুল।"

          },

          "vip_qa": {

            "question_en": "What is the difference between an 'Epic', a 'Story', and a 'Task' in Jira?",

            "answer_en": "They form a hierarchy. An **Epic** is a large body of work. An Epic is broken down into smaller **Stories** (user-centric features). A Story is then broken down into technical **Tasks** for developers."

          }

        },

        {

          "id": 83,

          "level": "Intermediate",

          "sub_topic": "Build Tools",

          "question_en": "What are the roles of Webpack and Babel?",

          "question_bn": "Webpack এবং Babel-এর কাজ কী?",

          "details": {

            "what_is_en": "**Webpack** is a module bundler. **Babel** is a JavaScript transpiler that converts modern JS into backward-compatible versions.",

            "what_is_bn": "**Webpack** একটি মডিউল বান্ডলার। **Babel** একটি জাভাস্ক্রিপ্ট কম্পাইলার।"

          },

          "vip_qa": {

            "question_en": "Explain the difference between a Webpack 'loader' and a 'plugin'.",

            "answer_en": "**Loaders** work at the individual file level, transforming them (e.g., `babel-loader` transforms a `.js` file). **Plugins** work at the bundle level and can modify the entire compilation process (e.g., `HtmlWebpackPlugin` generates an HTML file)."

          }

        },

        {

          "id": 84,

          "level": "Intermediate",

          "sub_topic": "Design Handoff",

          "question_en": "What is Figma?",

          "question_bn": "Figma কী?",

          "details": {

            "what_is_en": "Figma is a cloud-based design and prototyping tool for UI/UX design.",

            "what_is_bn": "Figma একটি ক্লাউড-ভিত্তিক ডিজাইন এবং প্রোটোটাইপিং টুল।"

          },

          "vip_qa": {

            "question_en": "As a developer, what should you look for in a Figma handoff?",

            "answer_en": "Look for: 1. **Design System Specs:** Clear definitions of colors, typography, and spacing. 2. **Component States:** Designs for all interactive states (hover, focus, disabled). 3. **Layout and Grids:** Information on responsive grids. 4. **Exportable Assets:** Icons and images marked as exportable, preferably as SVG."

          }

        },

        {

          "id": 85,

          "level": "Expert",

          "sub_topic": "Code Editing",

          "question_en": "What are some productivity tips for VS Code?",

          "question_bn": "VS Code এর কিছু প্রোডাক্টিভিটি টিপস কী?",

          "details": {

            "what_is_en": "Use keyboard shortcuts, multi-cursor editing, the command palette (Ctrl/Cmd+Shift+P), and install relevant extensions.",

            "what_is_bn": "কিবোর্ড শর্টকাট, মাল্টি-কার্সর এডিটিং, কমান্ড প্যালেট এবং দরকারি এক্সটেনশন ব্যবহার করুন।"

          },

          "vip_qa": {

            "question_en": "What is the purpose of the `launch.json` file in VS Code?",

            "answer_en": "The `launch.json` file configures the debugger. It defines launch configurations specifying how to start a debugging session, such as running a specific file, attaching to a running process, or setting environment variables."

          }

        }

      ]

    },

    {

      "topic": "DevOps & Deployment",

      "questions": [

        {

          "id": 86,

          "level": "Intermediate",

          "sub_topic": "Hosting Platforms",

          "question_en": "What are Vercel and Netlify?",

          "question_bn": "Vercel এবং Netlify কী?",

          "details": {

            "what_is_en": "Vercel and Netlify are modern web hosting and automation platforms for deploying frontend applications.",

            "what_is_bn": "Vercel এবং Netlify দুটিই আধুনিক ওয়েব হোস্টিং প্ল্যাটফর্ম।"

          },

          "vip_qa": {

            "question_en": "Why is Vercel the preferred platform for deploying Next.js applications?",

            "answer_en": "Vercel created Next.js, so the platform is perfectly optimized to support all of Next.js's features out-of-the-box (SSR, SSG, ISR, API Routes, etc.) with zero configuration."

          }

        },

        {

          "id": 87,

          "level": "Advanced",

          "sub_topic": "Server Configuration",

          "question_en": "What is a Reverse Proxy?",

          "question_bn": "Reverse Proxy কী?",

          "details": {

            "what_is_en": "A reverse proxy is a server that sits in front of one or more web servers, forwarding client requests to them.",

            "what_is_bn": "Reverse Proxy হলো এমন একটি সার্ভার যা ক্লায়েন্টের রিকোয়েস্ট গ্রহণ করে ব্যাকএন্ড সার্ভারের কাছে ফরোয়ার্ড করে।"

          },

          "vip_qa": {

            "question_en": "What are the key benefits of using a reverse proxy like Nginx for a Node.js app?",

            "answer_en": "1. **Load Balancing:** Distributes traffic across multiple Node.js instances. 2. **SSL Termination:** Offloads HTTPS decryption work from the Node.js app. 3. **Serving Static Content:** Nginx is highly efficient at serving static files. 4. **Security:** Hides the identity of your backend servers."

          }

        },

        {

          "id": 88,

          "level": "Advanced",

          "sub_topic": "Security",

          "question_en": "What is SSL/HTTPS?",

          "question_bn": "SSL/HTTPS কী?",

          "details": {

            "what_is_en": "SSL is a protocol for encrypting data sent between a client and a server. HTTPS is the secure version of HTTP that uses SSL.",

            "what_is_bn": "SSL একটি প্রোটোকল যা ডেটাকে এনক্রিপ্ট করে। HTTPS হলো HTTP-এর সুরক্ষিত ভার্সন।"

          },

          "vip_qa": {

            "question_en": "What are the three main benefits of using HTTPS?",

            "answer_en": "1. **Encryption:** Protects data integrity and privacy. 2. **Trust:** Provides authentication, verifying users are communicating with the correct website. 3. **SEO:** Search engines use HTTPS as a positive ranking signal."

          }

        }

      ]

    },

    {

      "topic": "AI & Content Creation",

      "questions": [

        {

          "id": 89,

          "level": "Intermediate",

          "sub_topic": "AI Code Assistants",

          "question_en": "What is GitHub Copilot?",

          "question_bn": "GitHub Copilot কী?",

          "details": {

            "what_is_en": "GitHub Copilot is an AI-powered code assistant that suggests code and entire functions in real-time.",

            "what_is_bn": "GitHub Copilot হলো একটি AI-চালিত কোড অ্যাসিস্ট্যান্ট যা রিয়েল-টাইমে কোড সাজেস্ট করে।"

          },

          "vip_qa": {

            "question_en": "What is a potential pitfall of relying on AI for coding?",

            "answer_en": "The biggest danger is **blindly accepting suggestions** without understanding them. The AI can generate code that is subtly incorrect, inefficient, or has security vulnerabilities. The developer must always be the final reviewer."

          }

        },

        {

          "id": 90,

          "level": "Intermediate",

          "sub_topic": "LLMs",

          "question_en": "How can LLMs like ChatGPT/Gemini help developers?",

          "question_bn": "ChatGPT/Gemini কীভাবে ডেভেলপারদের সাহায্য করে?",

          "details": {

            "what_is_en": "LLMs can help with debugging, explaining complex concepts, generating code snippets, and writing documentation.",

            "what_is_bn": "LLM এরর ব্যাখ্যা করে, জটিল বিষয় সহজ করে, কোড স্নিপেট তৈরি করে এবং ডকুমেন্টেশন লিখে সাহায্য করতে পারে।"

          },

          "vip_qa": {

            "question_en": "What is 'prompt engineering'?",

            "answer_en": "**Prompt engineering** is the skill of crafting effective inputs (prompts) to get the most accurate and useful outputs from an AI model. It involves providing clear context, constraints, and examples to guide the model."

          }

        },

        {

          "id": 91,

          "level": "Basic",

          "sub_topic": "Graphic Design",

          "question_en": "What is the difference between Photoshop and Illustrator?",

          "question_bn": "Photoshop এবং Illustrator-এর মধ্যে পার্থক্য কী?",

          "details": {

            "what_is_en": "**Photoshop** is a raster-based editor (pixels), ideal for photo editing. **Illustrator** is a vector-based editor (paths), ideal for logos and icons.",

            "what_is_bn": "**Photoshop** একটি রাস্টার-ভিত্তিক এডিটর। **Illustrator** একটি ভেক্টর-ভিত্তিক এডিটর।"

          },

          "vip_qa": {

            "question_en": "As a developer, when should you use a vector (SVG) versus a raster (PNG) format?",

            "answer_en": "Always use **vectors (SVG)** for logos, icons, and simple illustrations because they are scalable without quality loss. Use **raster formats (PNG, WebP)** for complex images like photographs."

          }

        }

      ]

    }

  ]

}